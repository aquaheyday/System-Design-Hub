# server scaling

## 수직적 규모 확장 과 수평적 규모 확장

수직적 규모 확장
수직적 규모 확장(vertical scaling)은 스케일 업(scale up)이라고도 한다.
프로세스는 서버에 고사양 자원(더 좋은 cpu, 더 많은 ram 등)을 추가하는 행위를 말한다.

수평적 규모 확장
스케일 아웃(scale out) 이라고도 한다.
프로세스는 더 많은 서버를 추가하여 서능을 개선하는 행위를 말한다.

서버로 유입되는 트래픽의 양이 적을 때는 수직적 확장이 좋은 선택이며, 이 방법의 가장 큰 장점은 단순함이다. 그러나 이 방법에는 몇 가지 심각한 단점이 존재한다.

- 수직적 규모 확장에는 한계가 있다. 한 대의 서버에 cpu나 메모리를 무한대로 증설할 방법은 없다.
- 수직적 규모 확장법은 장애에 대한 자동복구(failover) 바ㅇ안이나 다중와(re-dundancy) 방안을 제시하지 않는다. 서버에 장애가 발생하면 서비스는 완전히 중단된다.

이런 단점 때문에, 대규모 애플리케이션에는 수평적 규모 확장법이 보다 적절하다.

## 로드밸런서

로드밸런서는 부하 분산 집합에 속한 서버들에게 트래픽 부하를 고르게 분산하는 역할을 합니다. 

![Image](/drawio/로드밸런스.drawio.png)

사용자는 로드밸런서의 공개 IP 주소로 접속한다.  
서버간 통신에는 사설 IP 주소가 이용된다.  
사설 IP 주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있으며, 인터넷을 통해서는 접속할 수 없다.  

서버 1이 다운되면 모든 트래픽은 서버 2로 전송된다. 따라서 서비스가 중지되는 일을 방지한다.  
웹 서버 계층에 더 많은 서버를 추가하기만하면 로드밸런스가 자동적으로 트래픽을 분산한다.

## 데이터베이스 다중화

보통 서버 사이에 주(master)-부(slave) 관계를 설정하고 데이터 원본은 주 서버에 사본은 부 서버에 저장하는 방식이다. 
쓰기 연산(write operaion)은 마스터에서만 지원한다. 부 데이터베이스는 주 데이터베이스로부터 그 사본을 전달받아 읽기 연산(read operation)만을 지원한다. 
데이터베이스르 변견하는 명령어들(insert, delete, update) 등은 주 데이터베이스로만 전달되어야한다. 
대부분의 경우 읽기 연산의 비중이 쓰기 연산보다 훨씬 높다. 따라서 통상 부 데이터베이스 수가 주 데이터베이스 수 보다 많다. 

![Image](/drawio/데이터베이스-다중화.drawio.png)

장점 
- 병렬로 처리될 질의(query)의 수가 늘어나므로 성능이 좋아진다.
- 데이터를 지역적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있기 때문에 자연 재해로 부터 안정성을 확보할 수 있다.
- 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스가 가능하다.


## 로드밸런스 와 데이터베이스 다중화

![Image](/drawio/로드밸런스-데이터베이스-다중화.drawio.png)

1. 사용자는 DNS로 부터 로드밸런스의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP 주소로 로드밸런스에 접속한다.
3. 로드밸런스에서 서버 1 또는 서버 2 사설 IP 주소로 전달된다.
4. 웹 서버는 데이터 조회는 부 데이터베이스 서버에서 읽는다.
5. 웹 서버는 데이터 변경(추가, 삭제, 갱신 등)은 주 데이터베이스 서버로 전달한다.
  
## 캐시

캐시는 연산 결과 또는 자주 참조되는 데이터를 메모리에 두고 다음 요청이 보다 빠르게 처리될 수 있도록하는 저장소이다. 
애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데 캐시를 사용하면 해당 문제를 완화할 수 있다.

캐시계층은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 속도가 빠르다. 별도의 캐시 계층을 운용하면 성능이 개선될 뿐 아니라 데이터베이스의 부하를 줄일 수 있고 캐시 계층의 규모를 독립적으로 확장하는것도 가능해진다.

![Image](/drawio/캐시.drawio.png)

웹 서버는 캐시에 응답이 저장되어 있는지 확인한다.  
캐시에 저장된 데이터가 있다면 클라이언트에게 반환한다.  
캐시에 저장된 데이터가 없다면 데이터베이스 질의를 통해 데이터를 찾아 캐시에 저장한 뒤 클라이언트에 반환한다.  

이러한 캐시 전략을 캐시 우선 읽기 전략(read-through caching stategy)이라고 부른다.  
이외에도 다양한 캐시 전략이 있으니 상황에 맞는 전략을 선택하면된다.

## 콘텐츠 전송 네트워크(CDN)

CDN은 정적 콘텐츠를 전송하는데 쓰이는 분산된 서버의 네트워크이다.  
이미지, 비디오, CSS, Javascript 파일 등을 캐시할 수 있다. 

![Image](/drawio/지리적-CDN.drawio.png)

사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달하게 되어 로딩 속도를 개선할 수 있다.

![Image](/drawio/CDN.drawio.png)

1. 클라이언트1 이 이미지URL을 이용해 Image.png에 접근한다.
2. CDN 서버의 캐시에 해당 이미지가 없는 경우, CDN 서버는 원본 서버에 파일을 요청하여 가져온다. (원본 서버는 웹 서버일 수도 잇꼬 아마존 S3같은 온라인 저장소일 수 있다.)
3. 원본 서버가 파일을 CDN 서버에 반환한다. HTTP 헤더에 얼마나 오래 캐시할 것인지를 정하는 TTL(Time-To-Live)값이 포함되어있다.
4. CDN 서버는 파일을 캐시하고 클라이언트1에게 Image.png를 반환한다. 이미지는 TTL에 명시된 시간이 끝나기 전까지 캐시된다.
5. 클라이언트2는 CDN에 Image.png를 요청한다.
6. 만료되지 않은 이미지에 대한 요청은 CDN 캐시에서 바로 제공된다.

CDN 사용시 적절한 만료 기간을 설정해야한다. 캐시 기간이 너무 길면 콘텐츠의 신선도는 떨어지고 너무 짧으면 원본 서버에 빈번히 접속하게되어 성능에 좋지 못하다.  
CDN 장애에 대한 방어가 필요하다. CDN 자체가 죽었을 경우 원본 서버에서 직접 콘텐츠를 가져오도록 구성하는것이 필요할 수 있다.  
오브젝트 버저닝(object bersioning)을 이용하면 콘텐츠가 아직 만료되지않더라도 새로운 버전을 제공할 수 있다. Image.png?v=2 와 같은 형식이다.

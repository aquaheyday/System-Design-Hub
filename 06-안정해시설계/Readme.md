수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 배분하는 것이 중요하다. 안정 해시는 이 목표를 달성하기 위해 보편적으로 사용되는 기술이다.

## 해시 키 재배치(rehash) 문제

N개의 캐시 서버가 있다고 하자. 이 서버들에 부하를 균등하게 나누는 보편적 방법은 해시 함수를 사용하는 것이다.  
serverIndex=hash(key) % N  

총 4대의 서버를 사용한다고하자. 다음 표는 주어진 각각의 키에 대해서 해시 값과 서버 인덱스를 계산한 예제이다. 
| 키 | 해시 | 해시 % 4 (서버인덱스) |
|-------|-------|-------|
| key0  | 42342433 | 1 |
| key1  | 12321432 | 0 |
| key2  | 18014787 | 3 |
| key3  | 78979832 | 0 |
| key4  | 90384553 | 1 |
| key5  | 24402591 | 3 |
| key6  | 82221570 | 2 |
| key7  | 66961810 | 2 |

특정한 키가 보관된 서버를 알아내기 위해, 나머지(modular) 연산을 f(key) % 4 와 같이 적용하였다.  
예를 들어 hash(key0) % 4 = 1 이면, 클라이언트는 캐시에 보관된 데이터를 가져오기 위해 서버 1에 접속하여야 한다.

![Image](/drawio/해시키-균등-배치.drawio.png)

키 값이 서버에 어떻게 분산되는지 보여준다. 이 방법은 서버 풀(server pool)의 크기가 고정되어있고, 데이터 분포가 균들할 때 잘 동작한다. 하지만 서버가 추가되거나 기존 서버가 삭제되면 문제가 생긴다. 예를 들어 1번 서버가 장애를 일으켜 동작을 중단했다고 하자. 서버 풀의 크기는 3으로 변한다. 그 결과로, 키에 대한 해시 값은 변하지 않지만 나머지(%) 연산을 적용하여 계산한 서버 인덱스 값은달라질 것이다.

| 키 | 해시 | 해시 % 3 (서버인덱스) |
|-------|-------|-------|
| key0  | 42342433 | 1 |
| key1  | 12321432 | 0 |
| key2  | 18014787 | 0 |
| key3  | 78979832 | 2 |
| key4  | 90384553 | 1 |
| key5  | 24402591 | 0 |
| key6  | 82221570 | 0 |
| key7  | 66961810 | 1 |

변화된 키 분포(distribution)을 보자.

![Image](/drawio/해시키-비균등-배치.drawio.png)

장애가 발생한 1번 서버에 보관되어 있는 키 뿐만 아닌 대부분의 키가 재분배 되었다. 1번 서버가 죽으면 대부분 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다는 뜻이다. 그 결과로 대규모 캐시 미스(cache miss)가 발생하게 될 것이다. 안정 해시는 이 문제를 효과적으로 해결하는 기술이다.

## 안정 해시
